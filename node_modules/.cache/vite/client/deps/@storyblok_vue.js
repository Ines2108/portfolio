import {
  createBlock,
  defineAsyncComponent,
  defineComponent,
  inject,
  mergeProps,
  onMounted,
  openBlock,
  ref,
  resolveDynamicComponent
} from "./chunk-L5BJSZYY.js";

// node_modules/@storyblok/vue/dist/storyblok-vue.mjs
var j = false;
var x = [];
var H = (o) => new Promise((t, e) => {
  if (typeof window > "u" || (window.storyblokRegisterEvent = (r) => {
    if (window.location === window.parent.location) {
      console.warn("You are not in Draft Mode or in the Visual Editor.");
      return;
    }
    j ? r() : x.push(r);
  }, document.getElementById("storyblok-javascript-bridge")))
    return;
  const s = document.createElement("script");
  s.async = true, s.src = o, s.id = "storyblok-javascript-bridge", s.onerror = (r) => e(r), s.onload = (r) => {
    x.forEach((n) => n()), j = true, t(r);
  }, document.getElementsByTagName("head")[0].appendChild(s);
});
var q = Object.defineProperty;
var V = (o, t, e) => t in o ? q(o, t, { enumerable: true, configurable: true, writable: true, value: e }) : o[t] = e;
var h = (o, t, e) => (V(o, typeof t != "symbol" ? t + "" : t, e), e);
function C(o) {
  return !(o !== o || o === 1 / 0 || o === -1 / 0);
}
function D(o, t, e) {
  if (!C(t))
    throw new TypeError("Expected `limit` to be a finite number");
  if (!C(e))
    throw new TypeError("Expected `interval` to be a finite number");
  const s = [];
  let r = [], n = 0;
  const i = function() {
    n++;
    const a = setTimeout(function() {
      n--, s.length > 0 && i(), r = r.filter(function(u) {
        return u !== a;
      });
    }, e);
    r.indexOf(a) < 0 && r.push(a);
    const c = s.shift();
    c.resolve(o.apply(c.self, c.args));
  }, l = function(...a) {
    const c = this;
    return new Promise(function(u, p) {
      s.push({
        resolve: u,
        reject: p,
        args: a,
        self: c
      }), n < t && i();
    });
  };
  return l.abort = function() {
    r.forEach(clearTimeout), r = [], s.forEach(function(a) {
      a.reject(function() {
        Error.call(this, "Throttled function aborted"), this.name = "AbortError";
      });
    }), s.length = 0;
  }, l;
}
var k = class {
  constructor() {
    h(this, "isCDNUrl", (t = "") => t.indexOf("/cdn/") > -1), h(this, "getOptionsPage", (t, e = 25, s = 1) => ({
      ...t,
      per_page: e,
      page: s
    })), h(this, "delay", (t) => new Promise((e) => setTimeout(e, t))), h(this, "arrayFrom", (t = 0, e) => [...Array(t)].map(e)), h(this, "range", (t = 0, e = t) => {
      const s = Math.abs(e - t) || 0, r = t < e ? 1 : -1;
      return this.arrayFrom(s, (n, i) => i * r + t);
    }), h(this, "asyncMap", async (t, e) => Promise.all(t.map(e))), h(this, "flatMap", (t = [], e) => t.map(e).reduce((s, r) => [...s, ...r], [])), h(this, "escapeHTML", function(t) {
      const e = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      }, s = /[&<>"']/g, r = RegExp(s.source);
      return t && r.test(t) ? t.replace(s, (n) => e[n]) : t;
    });
  }
  /**
   * @method stringify
   * @param  {Object} params
   * @param  {String} prefix
   * @param  {Boolean} isArray
   * @return {String} Stringified object
   */
  stringify(t, e, s) {
    const r = [];
    for (const n in t) {
      if (!Object.prototype.hasOwnProperty.call(t, n))
        continue;
      const i = t[n], l = s ? "" : encodeURIComponent(n);
      let a;
      typeof i == "object" ? a = this.stringify(
        i,
        e ? e + encodeURIComponent("[" + l + "]") : l,
        Array.isArray(i)
      ) : a = (e ? e + encodeURIComponent("[" + l + "]") : l) + "=" + encodeURIComponent(i), r.push(a);
    }
    return r.join("&");
  }
  /**
   * @method getRegionURL
   * @param  {String} regionCode region code, could be eu, us, cn, ap or ca
   * @return {String} The base URL of the region
   */
  getRegionURL(t) {
    const e = "api.storyblok.com", s = "api-us.storyblok.com", r = "app.storyblokchina.cn", n = "api-ap.storyblok.com", i = "api-ca.storyblok.com";
    switch (t) {
      case "us":
        return s;
      case "cn":
        return r;
      case "ap":
        return n;
      case "ca":
        return i;
      default:
        return e;
    }
  }
};
var B = function(o, t) {
  const e = {};
  for (const s in o) {
    const r = o[s];
    t.indexOf(s) > -1 && r !== null && (e[s] = r);
  }
  return e;
};
var J = (o) => o === "email";
var K = () => ({
  singleTag: "hr"
});
var Y = () => ({
  tag: "blockquote"
});
var W = () => ({
  tag: "ul"
});
var G = (o) => ({
  tag: [
    "pre",
    {
      tag: "code",
      attrs: o.attrs
    }
  ]
});
var Q = () => ({
  singleTag: "br"
});
var X = (o) => ({
  tag: `h${o.attrs.level}`
});
var Z = (o) => ({
  singleTag: [
    {
      tag: "img",
      attrs: B(o.attrs, ["src", "alt", "title"])
    }
  ]
});
var tt = () => ({
  tag: "li"
});
var et = () => ({
  tag: "ol"
});
var st = () => ({
  tag: "p"
});
var rt = (o) => ({
  tag: [
    {
      tag: "span",
      attrs: {
        "data-type": "emoji",
        "data-name": o.attrs.name,
        emoji: o.attrs.emoji
      }
    }
  ]
});
var ot = () => ({
  tag: "b"
});
var nt = () => ({
  tag: "s"
});
var it = () => ({
  tag: "u"
});
var at = () => ({
  tag: "strong"
});
var lt = () => ({
  tag: "code"
});
var ct = () => ({
  tag: "i"
});
var ht = (o) => {
  if (!o.attrs)
    return {
      tag: ""
    };
  const t = new k().escapeHTML, e = { ...o.attrs }, { linktype: s = "url" } = o.attrs;
  if (delete e.linktype, e.href && (e.href = t(o.attrs.href || "")), J(s) && (e.href = `mailto:${e.href}`), e.anchor && (e.href = `${e.href}#${e.anchor}`, delete e.anchor), e.custom) {
    for (const r in e.custom)
      e[r] = e.custom[r];
    delete e.custom;
  }
  return {
    tag: [
      {
        tag: "a",
        attrs: e
      }
    ]
  };
};
var ut = (o) => ({
  tag: [
    {
      tag: "span",
      attrs: o.attrs
    }
  ]
});
var pt = () => ({
  tag: "sub"
});
var dt = () => ({
  tag: "sup"
});
var gt = (o) => ({
  tag: [
    {
      tag: "span",
      attrs: o.attrs
    }
  ]
});
var ft = (o) => {
  var t;
  return (t = o.attrs) != null && t.color ? {
    tag: [
      {
        tag: "span",
        attrs: {
          style: `background-color:${o.attrs.color};`
        }
      }
    ]
  } : {
    tag: ""
  };
};
var mt = (o) => {
  var t;
  return (t = o.attrs) != null && t.color ? {
    tag: [
      {
        tag: "span",
        attrs: {
          style: `color:${o.attrs.color}`
        }
      }
    ]
  } : {
    tag: ""
  };
};
var yt = {
  nodes: {
    horizontal_rule: K,
    blockquote: Y,
    bullet_list: W,
    code_block: G,
    hard_break: Q,
    heading: X,
    image: Z,
    list_item: tt,
    ordered_list: et,
    paragraph: st,
    emoji: rt
  },
  marks: {
    bold: ot,
    strike: nt,
    underline: it,
    strong: at,
    code: lt,
    italic: ct,
    link: ht,
    styled: ut,
    subscript: pt,
    superscript: dt,
    anchor: gt,
    highlight: ft,
    textStyle: mt
  }
};
var bt = function(o) {
  const t = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  }, e = /[&<>"']/g, s = RegExp(e.source);
  return o && s.test(o) ? o.replace(e, (r) => t[r]) : o;
};
var v = class {
  constructor(t) {
    h(this, "marks"), h(this, "nodes"), t || (t = yt), this.marks = t.marks || [], this.nodes = t.nodes || [];
  }
  addNode(t, e) {
    this.nodes[t] = e;
  }
  addMark(t, e) {
    this.marks[t] = e;
  }
  render(t, e = { optimizeImages: false }) {
    if (t && t.content && Array.isArray(t.content)) {
      let s = "";
      return t.content.forEach((r) => {
        s += this.renderNode(r);
      }), e.optimizeImages ? this.optimizeImages(s, e.optimizeImages) : s;
    }
    return console.warn(
      `The render method must receive an Object with a "content" field.
			The "content" field must be an array of nodes as the type ISbRichtext.
			ISbRichtext:
				content?: ISbRichtext[]
				marks?: ISbRichtext[]
				attrs?: any
				text?: string
				type: string
				
				Example:
				{
					content: [
						{
							content: [
								{
									text: 'Hello World',
									type: 'text'
								}
							],
							type: 'paragraph'
						}
					],
					type: 'doc'
				}`
    ), "";
  }
  optimizeImages(t, e) {
    let s = 0, r = 0, n = "", i = "";
    typeof e != "boolean" && (typeof e.width == "number" && e.width > 0 && (n += `width="${e.width}" `, s = e.width), typeof e.height == "number" && e.height > 0 && (n += `height="${e.height}" `, r = e.height), (e.loading === "lazy" || e.loading === "eager") && (n += `loading="${e.loading}" `), typeof e.class == "string" && e.class.length > 0 && (n += `class="${e.class}" `), e.filters && (typeof e.filters.blur == "number" && e.filters.blur >= 0 && e.filters.blur <= 100 && (i += `:blur(${e.filters.blur})`), typeof e.filters.brightness == "number" && e.filters.brightness >= -100 && e.filters.brightness <= 100 && (i += `:brightness(${e.filters.brightness})`), e.filters.fill && (e.filters.fill.match(/[0-9A-Fa-f]{6}/g) || e.filters.fill === "transparent") && (i += `:fill(${e.filters.fill})`), e.filters.format && ["webp", "png", "jpeg"].includes(e.filters.format) && (i += `:format(${e.filters.format})`), typeof e.filters.grayscale == "boolean" && e.filters.grayscale && (i += ":grayscale()"), typeof e.filters.quality == "number" && e.filters.quality >= 0 && e.filters.quality <= 100 && (i += `:quality(${e.filters.quality})`), e.filters.rotate && [90, 180, 270].includes(e.filters.rotate) && (i += `:rotate(${e.filters.rotate})`), i.length > 0 && (i = "/filters" + i))), n.length > 0 && (t = t.replace(/<img/g, `<img ${n.trim()}`));
    const l = s > 0 || r > 0 || i.length > 0 ? `${s}x${r}${i}` : "";
    return t = t.replace(
      /a.storyblok.com\/f\/(\d+)\/([^.]+)\.(gif|jpg|jpeg|png|tif|tiff|bmp)/g,
      `a.storyblok.com/f/$1/$2.$3/m/${l}`
    ), typeof e != "boolean" && (e.sizes || e.srcset) && (t = t.replace(/<img.*?src=["|'](.*?)["|']/g, (a) => {
      var c, u;
      const p = a.match(
        /a.storyblok.com\/f\/(\d+)\/([^.]+)\.(gif|jpg|jpeg|png|tif|tiff|bmp)/g
      );
      if (p && p.length > 0) {
        const g = {
          srcset: (c = e.srcset) == null ? void 0 : c.map((d) => {
            if (typeof d == "number")
              return `//${p}/m/${d}x0${i} ${d}w`;
            if (typeof d == "object" && d.length === 2) {
              let w = 0, S = 0;
              return typeof d[0] == "number" && (w = d[0]), typeof d[1] == "number" && (S = d[1]), `//${p}/m/${w}x${S}${i} ${w}w`;
            }
          }).join(", "),
          sizes: (u = e.sizes) == null ? void 0 : u.map((d) => d).join(", ")
        };
        let f = "";
        return g.srcset && (f += `srcset="${g.srcset}" `), g.sizes && (f += `sizes="${g.sizes}" `), a.replace(/<img/g, `<img ${f.trim()}`);
      }
      return a;
    })), t;
  }
  renderNode(t) {
    const e = [];
    t.marks && t.marks.forEach((r) => {
      const n = this.getMatchingMark(r);
      n && n.tag !== "" && e.push(this.renderOpeningTag(n.tag));
    });
    const s = this.getMatchingNode(t);
    return s && s.tag && e.push(this.renderOpeningTag(s.tag)), t.content ? t.content.forEach((r) => {
      e.push(this.renderNode(r));
    }) : t.text ? e.push(bt(t.text)) : s && s.singleTag ? e.push(this.renderTag(s.singleTag, " /")) : s && s.html ? e.push(s.html) : t.type === "emoji" && e.push(this.renderEmoji(t)), s && s.tag && e.push(this.renderClosingTag(s.tag)), t.marks && t.marks.slice(0).reverse().forEach((r) => {
      const n = this.getMatchingMark(r);
      n && n.tag !== "" && e.push(this.renderClosingTag(n.tag));
    }), e.join("");
  }
  renderTag(t, e) {
    return t.constructor === String ? `<${t}${e}>` : t.map((s) => {
      if (s.constructor === String)
        return `<${s}${e}>`;
      {
        let r = `<${s.tag}`;
        if (s.attrs)
          for (const n in s.attrs) {
            const i = s.attrs[n];
            i !== null && (r += ` ${n}="${i}"`);
          }
        return `${r}${e}>`;
      }
    }).join("");
  }
  renderOpeningTag(t) {
    return this.renderTag(t, "");
  }
  renderClosingTag(t) {
    return t.constructor === String ? `</${t}>` : t.slice(0).reverse().map((e) => e.constructor === String ? `</${e}>` : `</${e.tag}>`).join("");
  }
  getMatchingNode(t) {
    const e = this.nodes[t.type];
    if (typeof e == "function")
      return e(t);
  }
  getMatchingMark(t) {
    const e = this.marks[t.type];
    if (typeof e == "function")
      return e(t);
  }
  renderEmoji(t) {
    if (t.attrs.emoji)
      return t.attrs.emoji;
    const e = [
      {
        tag: "img",
        attrs: {
          src: t.attrs.fallbackImage,
          draggable: "false",
          loading: "lazy",
          align: "absmiddle"
        }
      }
    ];
    return this.renderTag(e, " /");
  }
};
var kt = class {
  constructor(t) {
    h(this, "baseURL"), h(this, "timeout"), h(this, "headers"), h(this, "responseInterceptor"), h(this, "fetch"), h(this, "ejectInterceptor"), h(this, "url"), h(this, "parameters"), h(this, "fetchOptions"), this.baseURL = t.baseURL, this.headers = t.headers || new Headers(), this.timeout = t != null && t.timeout ? t.timeout * 1e3 : 0, this.responseInterceptor = t.responseInterceptor, this.fetch = (...e) => t.fetch ? t.fetch(...e) : fetch(...e), this.ejectInterceptor = false, this.url = "", this.parameters = {}, this.fetchOptions = {};
  }
  /**
   *
   * @param url string
   * @param params ISbStoriesParams
   * @returns Promise<ISbResponse | Error>
   */
  get(t, e) {
    return this.url = t, this.parameters = e, this._methodHandler("get");
  }
  post(t, e) {
    return this.url = t, this.parameters = e, this._methodHandler("post");
  }
  put(t, e) {
    return this.url = t, this.parameters = e, this._methodHandler("put");
  }
  delete(t, e) {
    return this.url = t, this.parameters = e, this._methodHandler("delete");
  }
  async _responseHandler(t) {
    const e = [], s = {
      data: {},
      headers: {},
      status: 0,
      statusText: ""
    };
    t.status !== 204 && await t.json().then((r) => {
      s.data = r;
    });
    for (const r of t.headers.entries())
      e[r[0]] = r[1];
    return s.headers = { ...e }, s.status = t.status, s.statusText = t.statusText, s;
  }
  async _methodHandler(t) {
    let e = `${this.baseURL}${this.url}`, s = null;
    if (t === "get") {
      const a = new k();
      e = `${this.baseURL}${this.url}?${a.stringify(
        this.parameters
      )}`;
    } else
      s = JSON.stringify(this.parameters);
    const r = new URL(e), n = new AbortController(), { signal: i } = n;
    let l;
    this.timeout && (l = setTimeout(() => n.abort(), this.timeout));
    try {
      const a = await fetch(`${r}`, {
        method: t,
        headers: this.headers,
        body: s,
        signal: i,
        ...this.fetchOptions
      });
      this.timeout && clearTimeout(l);
      const c = await this._responseHandler(
        a
      );
      return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(c)) : this._statusHandler(c);
    } catch (a) {
      return {
        message: a
      };
    }
  }
  setFetchOptions(t = {}) {
    Object.keys(t).length > 0 && "method" in t && delete t.method, this.fetchOptions = { ...t };
  }
  eject() {
    this.ejectInterceptor = true;
  }
  _statusHandler(t) {
    const e = /20[0-6]/g;
    return new Promise((s, r) => {
      if (e.test(`${t.status}`))
        return s(t);
      const n = {
        message: t.statusText,
        status: t.status,
        response: Array.isArray(t.data) ? t.data[0] : t.data.error || t.data.slug
      };
      r(n);
    });
  }
};
var vt = { npm_package_version: "6.6.3" };
var P = "SB-Agent";
var R = {
  defaultAgentName: "SB-JS-CLIENT",
  defaultAgentVersion: "SB-Agent-Version",
  packageVersion: vt.npm_package_version
};
var b = {};
var m = {};
var wt = class {
  /**
   *
   * @param config ISbConfig interface
   * @param endpoint string, optional
   */
  constructor(t, e) {
    h(this, "client"), h(this, "maxRetries"), h(this, "throttle"), h(this, "accessToken"), h(this, "cache"), h(this, "helpers"), h(this, "resolveCounter"), h(this, "relations"), h(this, "links"), h(this, "richTextResolver"), h(this, "resolveNestedRelations"), h(this, "stringifiedStoriesCache");
    let s = t.endpoint || e;
    const r = new k().getRegionURL, n = t.https === false ? "http" : "https";
    t.oauthToken ? s = `${n}://${r(t.region)}/v1` : s = `${n}://${r(t.region)}/v2`;
    const i = new Headers();
    if (i.set("Content-Type", "application/json"), i.set("Accept", "application/json"), t.headers)
      for (const a in t.headers)
        i.set(a, t.headers[a]);
    i.has(P) || (i.set(P, R.defaultAgentName), i.set(
      R.defaultAgentVersion,
      R.packageVersion
    ));
    let l = 5;
    t.oauthToken && (i.set("Authorization", t.oauthToken), l = 3), t.rateLimit && (l = t.rateLimit), t.richTextSchema ? this.richTextResolver = new v(t.richTextSchema) : this.richTextResolver = new v(), t.componentResolver && this.setComponentResolver(t.componentResolver), this.maxRetries = t.maxRetries || 5, this.throttle = D(this.throttledRequest, l, 1e3), this.accessToken = t.accessToken || "", this.relations = {}, this.links = {}, this.cache = t.cache || { clear: "manual" }, this.helpers = new k(), this.resolveCounter = 0, this.resolveNestedRelations = t.resolveNestedRelations || true, this.stringifiedStoriesCache = {}, this.client = new kt({
      baseURL: s,
      timeout: t.timeout || 0,
      headers: i,
      responseInterceptor: t.responseInterceptor,
      fetch: t.fetch
    });
  }
  setComponentResolver(t) {
    this.richTextResolver.addNode("blok", (e) => {
      let s = "";
      return e.attrs.body && e.attrs.body.forEach((r) => {
        s += t(r.component, r);
      }), {
        html: s
      };
    });
  }
  parseParams(t) {
    return t.token || (t.token = this.getToken()), t.cv || (t.cv = m[t.token]), Array.isArray(t.resolve_relations) && (t.resolve_relations = t.resolve_relations.join(",")), t;
  }
  factoryParamOptions(t, e) {
    return this.helpers.isCDNUrl(t) ? this.parseParams(e) : e;
  }
  makeRequest(t, e, s, r) {
    const n = this.factoryParamOptions(
      t,
      this.helpers.getOptionsPage(e, s, r)
    );
    return this.cacheResponse(t, n);
  }
  get(t, e, s) {
    e || (e = {});
    const r = `/${t}`, n = this.factoryParamOptions(r, e);
    return this.client.setFetchOptions(s), this.cacheResponse(r, n);
  }
  async getAll(t, e, s, r) {
    const n = (e == null ? void 0 : e.per_page) || 25, i = `/${t}`, l = i.split("/"), a = s || l[l.length - 1], c = 1, u = await this.makeRequest(i, e, n, c), p = u.total ? Math.ceil(u.total / n) : 1;
    this.client.setFetchOptions(r);
    const g = await this.helpers.asyncMap(
      this.helpers.range(c, p),
      (f) => this.makeRequest(i, e, n, f + 1)
    );
    return this.helpers.flatMap(
      [u, ...g],
      (f) => Object.values(f.data[a])
    );
  }
  post(t, e, s) {
    const r = `/${t}`;
    return this.client.setFetchOptions(s), Promise.resolve(this.throttle("post", r, e));
  }
  put(t, e, s) {
    const r = `/${t}`;
    return this.client.setFetchOptions(s), Promise.resolve(this.throttle("put", r, e));
  }
  delete(t, e, s) {
    const r = `/${t}`;
    return this.client.setFetchOptions(s), Promise.resolve(this.throttle("delete", r, e));
  }
  getStories(t, e) {
    return this.client.setFetchOptions(e), this.get("cdn/stories", t);
  }
  getStory(t, e, s) {
    return this.client.setFetchOptions(s), this.get(`cdn/stories/${t}`, e);
  }
  getToken() {
    return this.accessToken;
  }
  ejectInterceptor() {
    this.client.eject();
  }
  _cleanCopy(t) {
    return JSON.parse(JSON.stringify(t));
  }
  _insertLinks(t, e, s) {
    const r = t[e];
    r && r.fieldtype == "multilink" && r.linktype == "story" && typeof r.id == "string" && this.links[s][r.id] ? r.story = this._cleanCopy(this.links[s][r.id]) : r && r.linktype === "story" && typeof r.uuid == "string" && this.links[s][r.uuid] && (r.story = this._cleanCopy(this.links[s][r.uuid]));
  }
  /**
   *
   * @param resolveId A counter number as a string
   * @param uuid The uuid of the story
   * @returns string | object
   */
  getStoryReference(t, e) {
    return this.relations[t][e] ? (this.stringifiedStoriesCache[e] || (this.stringifiedStoriesCache[e] = JSON.stringify(
      this.relations[t][e]
    )), JSON.parse(this.stringifiedStoriesCache[e])) : e;
  }
  _insertRelations(t, e, s, r) {
    s.indexOf(`${t.component}.${e}`) > -1 && (typeof t[e] == "string" ? t[e] = this.getStoryReference(r, t[e]) : Array.isArray(t[e]) && (t[e] = t[e].map((n) => this.getStoryReference(r, n)).filter(Boolean)));
  }
  iterateTree(t, e, s) {
    const r = (n) => {
      if (n != null) {
        if (n.constructor === Array)
          for (let i = 0; i < n.length; i++)
            r(n[i]);
        else if (n.constructor === Object) {
          if (n._stopResolving)
            return;
          for (const i in n)
            (n.component && n._uid || n.type === "link") && (this._insertRelations(
              n,
              i,
              e,
              s
            ), this._insertLinks(
              n,
              i,
              s
            )), r(n[i]);
        }
      }
    };
    r(t.content);
  }
  async resolveLinks(t, e, s) {
    let r = [];
    if (t.link_uuids) {
      const n = t.link_uuids.length, i = [], l = 50;
      for (let a = 0; a < n; a += l) {
        const c = Math.min(n, a + l);
        i.push(t.link_uuids.slice(a, c));
      }
      for (let a = 0; a < i.length; a++)
        (await this.getStories({
          per_page: l,
          language: e.language,
          version: e.version,
          by_uuids: i[a].join(",")
        })).data.stories.forEach(
          (c) => {
            r.push(c);
          }
        );
    } else
      r = t.links;
    r.forEach((n) => {
      this.links[s][n.uuid] = {
        ...n,
        _stopResolving: true
      };
    });
  }
  async resolveRelations(t, e, s) {
    let r = [];
    if (t.rel_uuids) {
      const n = t.rel_uuids.length, i = [], l = 50;
      for (let a = 0; a < n; a += l) {
        const c = Math.min(n, a + l);
        i.push(t.rel_uuids.slice(a, c));
      }
      for (let a = 0; a < i.length; a++)
        (await this.getStories({
          per_page: l,
          language: e.language,
          version: e.version,
          by_uuids: i[a].join(","),
          excluding_fields: e.excluding_fields
        })).data.stories.forEach((c) => {
          r.push(c);
        });
    } else
      r = t.rels;
    r && r.length > 0 && r.forEach((n) => {
      this.relations[s][n.uuid] = {
        ...n,
        _stopResolving: true
      };
    });
  }
  /**
   *
   * @param responseData
   * @param params
   * @param resolveId
   * @description Resolves the relations and links of the stories
   * @returns Promise<void>
   *
   */
  async resolveStories(t, e, s) {
    var r, n;
    let i = [];
    if (this.links[s] = {}, this.relations[s] = {}, typeof e.resolve_relations < "u" && e.resolve_relations.length > 0 && (typeof e.resolve_relations == "string" && (i = e.resolve_relations.split(",")), await this.resolveRelations(t, e, s)), e.resolve_links && ["1", "story", "url", "link"].indexOf(e.resolve_links) > -1 && ((r = t.links) != null && r.length || (n = t.link_uuids) != null && n.length) && await this.resolveLinks(t, e, s), this.resolveNestedRelations)
      for (const l in this.relations[s])
        this.iterateTree(
          this.relations[s][l],
          i,
          s
        );
    t.story ? this.iterateTree(t.story, i, s) : t.stories.forEach((l) => {
      this.iterateTree(l, i, s);
    }), this.stringifiedStoriesCache = {}, delete this.links[s], delete this.relations[s];
  }
  async cacheResponse(t, e, s) {
    (typeof s > "u" || !s) && (s = 0);
    const r = this.helpers.stringify({ url: t, params: e }), n = this.cacheProvider();
    if (this.cache.clear === "auto" && e.version === "draft" && await this.flushCache(), e.version === "published" && t != "/cdn/spaces/me") {
      const i = await n.get(r);
      if (i)
        return Promise.resolve(i);
    }
    return new Promise(async (i, l) => {
      var a;
      try {
        const c = await this.throttle("get", t, e);
        if (c.status !== 200)
          return l(c);
        let u = { data: c.data, headers: c.headers };
        if ((a = c.headers) != null && a["per-page"] && (u = Object.assign({}, u, {
          perPage: c.headers["per-page"] ? parseInt(c.headers["per-page"]) : 0,
          total: c.headers["per-page"] ? parseInt(c.headers.total) : 0
        })), u.data.story || u.data.stories) {
          const p = this.resolveCounter = ++this.resolveCounter % 1e3;
          await this.resolveStories(u.data, e, `${p}`);
        }
        return e.version === "published" && t != "/cdn/spaces/me" && await n.set(r, u), u.data.cv && e.token && (e.version === "draft" && m[e.token] != u.data.cv && await this.flushCache(), m[e.token] = e.cv ? e.cv : u.data.cv), i(u);
      } catch (c) {
        if (c.response && c.status === 429 && (s = s ? s + 1 : 0, s < this.maxRetries))
          return console.log(`Hit rate limit. Retrying in ${s} seconds.`), await this.helpers.delay(1e3 * s), this.cacheResponse(t, e, s).then(i).catch(l);
        l(c);
      }
    });
  }
  throttledRequest(t, e, s) {
    return this.client[t](e, s);
  }
  cacheVersions() {
    return m;
  }
  cacheVersion() {
    return m[this.accessToken];
  }
  setCacheVersion(t) {
    this.accessToken && (m[this.accessToken] = t);
  }
  cacheProvider() {
    switch (this.cache.type) {
      case "memory":
        return {
          get(t) {
            return Promise.resolve(b[t]);
          },
          getAll() {
            return Promise.resolve(b);
          },
          set(t, e) {
            return b[t] = e, Promise.resolve(void 0);
          },
          flush() {
            return b = {}, Promise.resolve(void 0);
          }
        };
      case "custom":
        if (this.cache.custom)
          return this.cache.custom;
      default:
        return {
          get() {
            return Promise.resolve();
          },
          getAll() {
            return Promise.resolve(void 0);
          },
          set() {
            return Promise.resolve(void 0);
          },
          flush() {
            return Promise.resolve(void 0);
          }
        };
    }
  }
  async flushCache() {
    return await this.cacheProvider().flush(), this;
  }
};
var Ct = (o = {}) => {
  const { apiOptions: t } = o;
  if (!t.accessToken) {
    console.error(
      "You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication"
    );
    return;
  }
  return { storyblokApi: new wt(t) };
};
var $t = (o) => {
  if (typeof o != "object" || typeof o._editable > "u")
    return {};
  try {
    const t = JSON.parse(
      o._editable.replace(/^<!--#storyblok#/, "").replace(/-->$/, "")
    );
    return t ? {
      "data-blok-c": JSON.stringify(t),
      "data-blok-uid": t.id + "-" + t.uid
    } : {};
  } catch {
    return {};
  }
};
var T;
var O = "https://app.storyblok.com/f/storyblok-v2-latest.js";
var Rt = (o, t, e = {}) => {
  var s;
  const r = !(typeof window > "u") && typeof window.storyblokRegisterEvent < "u", n = +new URL((s = window.location) == null ? void 0 : s.href).searchParams.get(
    "_storyblok"
  ) === o;
  if (!(!r || !n)) {
    if (!o) {
      console.warn("Story ID is not defined. Please provide a valid ID.");
      return;
    }
    window.storyblokRegisterEvent(() => {
      new window.StoryblokBridge(e).on(["input", "published", "change"], (i) => {
        i.action === "input" && i.story.id === o ? t(i.story) : (i.action === "change" || i.action === "published") && i.storyId === o && window.location.reload();
      });
    });
  }
};
var _t = (o = {}) => {
  var t, e;
  const {
    bridge: s,
    accessToken: r,
    use: n = [],
    apiOptions: i = {},
    richText: l = {},
    bridgeUrl: a
  } = o;
  i.accessToken = i.accessToken || r;
  const c = { bridge: s, apiOptions: i };
  let u = {};
  n.forEach((g) => {
    u = { ...u, ...g(c) };
  }), a && (O = a);
  const p = !(typeof window > "u") && ((e = (t = window.location) == null ? void 0 : t.search) == null ? void 0 : e.includes("_storyblok_tk"));
  return s !== false && p && H(O), T = new v(l.schema), l.resolver && I(T, l.resolver), u;
};
var I = (o, t) => {
  o.addNode("blok", (e) => {
    let s = "";
    return e.attrs.body.forEach((r) => {
      s += t(r.component, r);
    }), {
      html: s
    };
  });
};
var Tt = (o) => !o || !(o != null && o.content.some((t) => t.content || t.type === "blok" || t.type === "horizontal_rule"));
var Pt = (o, t, e) => {
  let s = e || T;
  if (!s) {
    console.error(
      "Please initialize the Storyblok SDK before calling the renderRichText function"
    );
    return;
  }
  return Tt(o) ? "" : (t && (s = new v(t.schema), t.resolver && I(s, t.resolver)), s.render(o));
};
var St = defineComponent({
  __name: "StoryblokComponent",
  props: {
    blok: {}
  },
  setup(o, { expose: t }) {
    const e = o, s = ref();
    t({
      value: s
    });
    const r = typeof resolveDynamicComponent(e.blok.component) != "string", n = inject("VueSDKOptions"), i = ref(e.blok.component);
    return r || (n.enableFallbackComponent ? (i.value = n.customFallbackComponent ?? "FallbackComponent", typeof resolveDynamicComponent(i.value) == "string" && console.error(
      `Is the Fallback component "${i.value}" registered properly?`
    )) : console.error(
      `Component could not be found for blok "${e.blok.component}"! Is it defined in main.ts as "app.component("${e.blok.component}", ${e.blok.component});"?`
    )), (l, a) => (openBlock(), createBlock(resolveDynamicComponent(i.value), mergeProps({
      ref_key: "blokRef",
      ref: s
    }, { ...l.$props, ...l.$attrs }), null, 16));
  }
});
var jt = {
  beforeMount(o, t) {
    if (t.value) {
      const e = $t(t.value);
      Object.keys(e).length > 0 && (o.setAttribute("data-blok-c", e["data-blok-c"]), o.setAttribute("data-blok-uid", e["data-blok-uid"]), o.classList.add("storyblok__outline"));
    }
  }
};
var E = (o) => {
  console.error(`You can't use ${o} if you're not loading apiPlugin. Please provide it on StoryblokVue initialization.
    `);
};
var y = null;
var Ot = () => (y || E("useStoryblokApi"), y);
var It = async (o, t = {}, e = {}) => {
  const s = ref(null);
  if (e.resolveRelations = e.resolveRelations ?? t.resolve_relations, e.resolveLinks = e.resolveLinks ?? t.resolve_links, onMounted(() => {
    s.value && s.value.id && Rt(
      s.value.id,
      (r) => s.value = r,
      e
    );
  }), y) {
    const { data: r } = await y.get(
      `cdn/stories/${o}`,
      t
    );
    s.value = r.story;
  } else
    E("useStoryblok");
  return s;
};
var Et = {
  install(o, t = {}) {
    o.directive("editable", jt), o.component("StoryblokComponent", St), t.enableFallbackComponent && !t.customFallbackComponent && o.component(
      "FallbackComponent",
      defineAsyncComponent(() => import("./FallbackComponent-hOszcW1L-Q2B6LB5B.js"))
    );
    const { storyblokApi: e } = _t(t);
    y = e, o.provide("VueSDKOptions", t);
  }
};
export {
  v as RichTextResolver,
  yt as RichTextSchema,
  St as StoryblokComponent,
  Et as StoryblokVue,
  Ct as apiPlugin,
  Pt as renderRichText,
  It as useStoryblok,
  Ot as useStoryblokApi,
  Rt as useStoryblokBridge
};
//# sourceMappingURL=@storyblok_vue.js.map
